/* tentative implementation algo radix sort */

/* adaptation de celui de geeksforgeeks */
void    radix_sort(t_stack **stack_a, t_stack **stack_b, int nb_elem)
{
    int max;
    int exp;

    max = find_max((*stack_a));
    exp = 1;
    while (max / exp > 0)
    {
        counting_sort(stack_a, stack_b, exp);
        exp *= 10;
    }
}

/* adaptation de programiz */
void    counting_sort(t_stack **stack_a, int size, int exp)
{
    int max;
    int i;
    t_stack *output;
    t_stack *count;

    max = ((*stack_a)->data / exp) % 10;
    i = 1;
    while (i < size)
    {
        if (((*stack_a)->data / exp) % 10 > max)
            max = (*stack_a)->data;
        i++;
        (*stack_a) = (*stack_a)->next;
    }
    i = 0;
    while (i < size)
    {
        count[((*stack_a)->data / place) % 10]++;
        i++;
        (*stack_a) = (*stack_a)->next;
    }
    i = 1;
    while (i < 10)
    {
        count[i] += count[i - 1];
        i++;
    }
    i = size - 1;
    while (i >= 0)
    {
        output[count[((*stack_a)->data / place) % 10] - 1] = (*stack_a)->data;
        count[((*stack_a)->data / place) % 10]--;
        i--;
        (*stack_a) = (*stack_a)->next;
    }
    i = 0;
    while (i < size)
    {
        (*stack_a)->data = output->data;
        i++;
        (*stack_a) = (*stack_a)->next;
        output = output->next;
    }
}

/* commun a tous */
int find_max(t_stack **stack_a)
{
    int res;

    res = 0;
    while ((*stack_a)->next != NULL)
    {
        if ((*stack_a)->data > res)
            res = (*stack_a)->data;
        (*stack_a) = (*stack_a)->next;
    }
    return (res);
}
